---

title: 复现数字货币多因子策略
date: 2023-09-02 16:07:00
categories:
  - 量化交易
tags:
  - 数字货币
  - 回测
  - 复现
  - 多因子
  - quant1098.com
  - digiccy
  - bitcoin
  - 策略
description: '关于多因子的量化交易策略，股票方面的资源很多，但是数字货币方面的文章并不多，这篇文章是发明者上面数字货币多因子策略的复刻，结果跟原版略有不同'
cover: https://s2.loli.net/2023/09/02/9x5WuNXh1A2jofR.png
---

## 缘起

### 股票和数字货币

数字货币市场作为一个7* 25 全年365天不停运转的交易市场，每天产生海量的数据，相比较A股市场每天交易时间只有4个小时，想获取毫秒级的数据千难万难。数字货币市场无疑是一个更加友好的市场。

昨天还跟发小吵了一架，他还是坚持认为量化是邪恶的，是在从他们手里偷钱。而我的观点是 量化是大趋势，会量化的面对不懂量化的传统交易者是在降维打击。唯一的办法就是尽快拥抱量化，但是 人各有志，不能强劝。

![](https://s2.loli.net/2023/09/02/gDhXbZAkSdz3T8c.png)

数字货币市场在不停的进化，从一个人手动搬砖就可以大把挣钱，到手动搬砖无法获利转向程序搬砖套利，再然后是用程序加上简单的指标进行程序化交易，再然后，简单的指标开始失效，代价逐渐开始引入因子概念。水平更高的开始向高频进军。

这一步一步可以明显看出。数字货币市场是一个逐渐从认知门槛到技术门槛转换的过程中，一开始只要你有赌的决心，就可以获取暴利，到现在你只有拨开眼前的迷雾，跨过认知的门槛，同时技术过硬才能获取到足以满足自己的利润。

这一切跟改开初期何其相似，只不过，这是一个5倍速的市场，一切都在快速进化中。希望看到这篇文章的同学能一起拥抱迎面而来的可以浪潮。获取属于自己的一份荣耀。

### 多因子与数字货币

说回多因子， 本文不涉及复杂的数学建模和逻辑推导， 就是简单的用数字货币现货市场作为数据源 来构建一个因子回测框架， 方便对因子进行评价。

因子可以看成是一个指标，也可以写成一个表达式，它代表了一种投资逻辑，反应了一种收益信息。

例如： 收盘价因子假设股价可预测未来收益,股价越高预示收益越高(或越低)。构建该因子组合等于定期轮换买入高价股的策略。能持续产生超额收益的因子通常称为Alpha,如经验证的有效因子——市值因子和动量因子等。

无论股市或数字货币市场,都极为复杂,无法完全预测未来收益,但仍有一定可预测性。有效的Alpha投资模式随更多资金投入逐渐失效,但会催生新模式、新Alpha。

市值因子曾在A股市场非常成功,2007年起十年回测,简单买最低市值股票,每天调整,获得超过400倍收益,远超大盘。但2017年小市值因子失效,价值因子反而流行,反映单一因子局限性。需在验证和使用因子间权衡。 寻找因子是策略基础,组合多个不相关有效因子可构建较佳策略。

## 代码实现

### 引入相关库

```python
# 引入相关库
import requests
from datetime import date,datetime
import time
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests, zipfile, io
%matplotlib inline
```

### 构建数据环境

数据来源是binance交易所的现货市场， 因为这些数据我已经全部存入数据库，方便本地回测和研究，我这次选取了交易量比较大，在USDT永续期货同时开通了交易对的品种，前面说过 多因子其实是一个选币策略，要求币种要足够多，才能有足够的挑选空间。

先构建数据库环境，方便数据调用

```python
## 定义数据库相关常量
start_time = "2022-01-01 00:00:00"
end_time = "2022-09-01 00:00:00"
rule_type = '1h'

df_dict = {}
date_columns = "open_time_GMT8"

username = ""
password = ""
host = ""
port = 3306
dbname = "binance_spot"

# 初始化数据库连接，使用pymysql模块
db = pymysql.connect(host=host, port=port,user=username, passwd=password,db=dbname, charset="utf8")
# 使用 cursor() 方法创建一个游标对象 cursor
con = db.cursor()
```

### 定义常用函数

然后定义常用的几个函数，方便调用

```python
#———————————————————— 定义相关函数 ————————————————————#
# 获取表名
def get_tables(con, dbname):
    con.execute("SHOW TABLES")
    results = con.fetchall()
    tables_name = [item for sublist in results for item in sublist]
    return tables_name

# 周期转换函数
def transfer_to_period_data(df, rule_type):
    period_df = df.resample(rule=rule_type, on='open_time_GMT8', label='left', closed='left').agg(
        {'open': 'first',
         'high': 'max',
         'low': 'min',
         'close': 'last',
         'volume': 'sum',
         'amount': 'sum'
         })

    period_df.dropna(subset=['open'], inplace=True)  # 去除一天都没有交易的周期
    period_df = period_df[period_df['volume'] > 0]  # 去除成交量为0的交易周期
    period_df.reset_index(inplace=True)
    all_data = period_df[['open_time_GMT8', 'open', 'high', 'low', 'close', 'volume', 'amount']]
    return all_data

def export_table_by_date(table_name, date_columns, start_date, end_date):
    """
    指定时间获取相关数据
    Args:
        table_name: eg. eth_usdt
        date_columns: 时间列 eg. "open_time_GMT8"
    Returns:Pandas.DataFrmae()
    """
    try:
        query = f"SELECT * FROM {table_name} WHERE {date_columns} BETWEEN '{start_date}' AND '{end_date}'"
        con.execute(query)
        results = con.fetchall()

        columns = []
        for i in range(len(con.description)):
            columns.append(con.description[i][0])

        df = pd.DataFrame(results, columns=columns)
        return df, None
    except Exception as e:
        return None, e    
```

### 打印数据库信息

我们先打印一下数据库内存有那些表

```python
## 获取指定数据库内所有表的表名
tables_names = get_tables(con, dbname)
print(tables_names, len(tables_names))
```

output:

```python
['1inch_usdt', 'aave_usdt', 'aca_usdt', 'ach_usdt', 'acm_usdt', 'ada_usdt', 'adx_usdt', 'agld_usdt', 'aion_usdt', 'akro_usdt', 'alcx_usdt', 'algo_usdt', 'alice_usdt', 'alpaca_usdt', 'alpha_usdt', 'alpine_usdt', 'amp_usdt', 'anc_usdt', 'ankr_usdt', 'ant_usdt', 'any_usdt', 'ape_usdt', 'api3_usdt', 'apt_usdt', 'ar_usdt', 'ardr_usdt', 'arpa_usdt', 'asr_usdt', 'astr_usdt', 'ata_usdt', 'atm_usdt', 'atom_usdt', 'auction_usdt', 'aud_usdt', 'audio_usdt', 'auto_usdt', 'ava_usdt', 'avax_usdt', 'axs_usdt', 'badger_usdt', 'bake_usdt', 'bal_usdt', 'band_usdt', 'bar_usdt', 'bat_usdt', 'bcc_usdt', 'bch_usdt', 'bchabc_usdt', 'bchsv_usdt', 'beam_usdt', 'bel_usdt', 'beta_usdt', 'bico_usdt', 'bifi_usdt', 'bkrw_usdt', 'blz_usdt', 'bnb_usdt', 'bnt_usdt', 'bnx_usdt', 'bond_usdt', 'bsw_usdt', 'btc_usdt', 'btcst_usdt', 'btg_usdt', 'bts_usdt', 'btt_usdt', 'bttc_usdt', 'burger_usdt', 'busd_usdt', 'bzrx_usdt', 'c98_usdt', 'cake_usdt', 'celo_usdt', 'celr_usdt', 'cfx_usdt', 'chess_usdt', 'chr_usdt', 'chz_usdt', 'city_usdt', 'ckb_usdt', 'clv_usdt', 'cocos_usdt', 'comp_usdt', 'cos_usdt', 'coti_usdt', 'crv_usdt', 'ctk_usdt', 'ctsi_usdt', 'ctxc_usdt', 'cvc_usdt', 'cvp_usdt', 'cvx_usdt', 'dai_usdt', 'dar_usdt', 'dash_usdt', 'data_usdt', 'dcr_usdt', 'dego_usdt', 'dent_usdt', 'dexe_usdt', 'df_usdt', 'dgb_usdt', 'dia_usdt', 'dnt_usdt', 'dock_usdt', 'dodo_usdt', 'doge_usdt', 'dot_usdt', 'drep_usdt', 'dusk_usdt', 'dydx_usdt', 'egld_usdt', 'elf_usdt', 'enj_usdt', 'ens_usdt', 'eos_usdt', 'eps_usdt', 'epx_usdt', 'erd_usdt', 'ern_usdt', 'etc_usdt', 'eth_usdt', 'eur_usdt', 'farm_usdt', 'fet_usdt', 'fida_usdt', 'fil_usdt', 'fio_usdt', 'firo_usdt', 'fis_usdt', 'flm_usdt', 'flow_usdt', 'flux_usdt', 'for_usdt', 'forth_usdt', 'front_usdt', 'ftm_usdt', 'ftt_usdt', 'fun_usdt', 'fxs_usdt', 'gal_usdt', 'gala_usdt', 'gbp_usdt', 'ghst_usdt', 'glmr_usdt', 'gmt_usdt', 'gmx_usdt', 'gno_usdt', 'grt_usdt', 'gtc_usdt', 'gto_usdt', 'gxs_usdt', 'hard_usdt', 'hbar_usdt', 'hc_usdt', 'hft_usdt', 'hifi_usdt', 'high_usdt', 'hive_usdt', 'hnt_usdt', 'hot_usdt', 'icp_usdt', 'icx_usdt', 'idex_usdt', 'ilv_usdt', 'imx_usdt', 'inj_usdt', 'iost_usdt', 'iota_usdt', 'iotx_usdt', 'iris_usdt', 'jasmy_usdt', 'joe_usdt', 'jst_usdt', 'juv_usdt', 'kava_usdt', 'kda_usdt', 'keep_usdt', 'key_usdt', 'klay_usdt', 'kmd_usdt', 'knc_usdt', 'kp3r_usdt', 'ksm_usdt', 'lazio_usdt', 'ldo_usdt', 'lend_usdt', 'lever_usdt', 'lina_usdt', 'link_usdt', 'lit_usdt', 'loka_usdt', 'lqty_usdt', 'lrc_usdt', 'lsk_usdt', 'ltc_usdt', 'lto_usdt', 'luna_usdt', 'magic_usdt', 'mana_usdt', 'mask_usdt', 'matic_usdt', 'mbl_usdt', 'mbox_usdt', 'mc_usdt', 'mco_usdt', 'mdt_usdt', 'mdx_usdt', 'mft_usdt', 'mina_usdt', 'mir_usdt', 'mith_usdt', 'mkr_usdt', 'mln_usdt', 'mob_usdt', 'movr_usdt', 'mtl_usdt', 'multi_usdt', 'nano_usdt', 'nbs_usdt', 'nbt_usdt', 'near_usdt', 'neo_usdt', 'nexo_usdt', 'nkn_usdt', 'nmr_usdt', 'npxs_usdt', 'nu_usdt', 'nuls_usdt', 'ocean_usdt', 'og_usdt', 'ogn_usdt', 'om_usdt', 'omg_usdt', 'one_usdt', 'ong_usdt', 'ont_usdt', 'ooki_usdt', 'op_usdt', 'orn_usdt', 'oxt_usdt', 'pax_usdt', 'paxg_usdt', 'people_usdt', 'perl_usdt', 'perp_usdt', 'pha_usdt', 'pla_usdt', 'pnt_usdt', 'pols_usdt', 'poly_usdt', 'polyx_usdt', 'pond_usdt', 'porto_usdt', 'powr_usdt', 'psg_usdt', 'pundix_usdt', 'pyr_usdt', 'qi_usdt', 'qnt_usdt', 'qtum_usdt', 'quick_usdt', 'rad_usdt', 'ramp_usdt', 'rare_usdt', 'ray_usdt', 'reef_usdt', 'rei_usdt', 'rep_usdt', 'req_usdt', 'rgt_usdt', 'rif_usdt', 'rlc_usdt', 'rndr_usdt', 'rose_usdt', 'rpl_usdt', 'rsr_usdt', 'rune_usdt', 'sand_usdt', 'santos_usdt', 'sc_usdt', 'scrt_usdt', 'sfp_usdt', 'shib_usdt', 'skl_usdt', 'slp_usdt', 'snx_usdt', 'sol_usdt', 'spell_usdt', 'srm_usdt', 'steem_usdt', 'stg_usdt', 'stmx_usdt', 'storj_usdt', 'storm_usdt', 'stpt_usdt', 'strat_usdt', 'strax_usdt', 'stx_usdt', 'sun_usdt', 'susd_usdt', 'sushi_usdt', 'sxp_usdt', 'sys_usdt', 't_usdt', 'tct_usdt', 'tfuel_usdt', 'theta_usdt', 'tko_usdt', 'tlm_usdt', 'tomo_usdt', 'torn_usdt', 'trb_usdt', 'tribe_usdt', 'troy_usdt', 'tru_usdt', 'trx_usdt', 'tusd_usdt', 'tvk_usdt', 'twt_usdt', 'uma_usdt', 'unfi_usdt', 'uni_usdt', 'usdc_usdt', 'usdp_usdt', 'ust_usdt', 'utk_usdt', 'ven_usdt', 'vet_usdt', 'vgx_usdt', 'vidt_usdt', 'vite_usdt', 'voxel_usdt', 'vtho_usdt', 'wan_usdt', 'waves_usdt', 'waxp_usdt', 'win_usdt', 'wing_usdt', 'wnxm_usdt', 'woo_usdt', 'wrx_usdt', 'wtc_usdt', 'xec_usdt', 'xem_usdt', 'xlm_usdt', 'xmr_usdt', 'xno_usdt', 'xrp_usdt', 'xtz_usdt', 'xvg_usdt', 'xvs_usdt', 'xzc_usdt', 'yfi_usdt', 'yfii_usdt', 'ygg_usdt', 'zec_usdt', 'zen_usdt', 'zil_usdt', 'zrx_usdt'] 360
```

再来输出表中的数据查看下数据结构 ：

```python
symbol = 'btc_usdt'
df, error = export_table_by_date(symbol, date_columns, start_time, end_time)
df
```

output：

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>open_time_GMT8</th>
      <th>open</th>
      <th>high</th>
      <th>low</th>
      <th>close</th>
      <th>volume</th>
      <th>amount</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2291854</td>
      <td>2022-01-01 00:00:00</td>
      <td>48005.37</td>
      <td>48027.31</td>
      <td>47937.50</td>
      <td>48004.75</td>
      <td>50.29149</td>
      <td>2.413640e+06</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2291855</td>
      <td>2022-01-01 00:01:00</td>
      <td>48007.21</td>
      <td>48011.78</td>
      <td>47951.50</td>
      <td>47951.50</td>
      <td>14.75541</td>
      <td>7.080488e+05</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2291856</td>
      <td>2022-01-01 00:02:00</td>
      <td>47956.29</td>
      <td>47992.36</td>
      <td>47944.49</td>
      <td>47965.46</td>
      <td>15.33062</td>
      <td>7.353789e+05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2291857</td>
      <td>2022-01-01 00:03:00</td>
      <td>47965.46</td>
      <td>47970.25</td>
      <td>47910.56</td>
      <td>47954.34</td>
      <td>13.35734</td>
      <td>6.403608e+05</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2291858</td>
      <td>2022-01-01 00:04:00</td>
      <td>47954.35</td>
      <td>47971.49</td>
      <td>47949.55</td>
      <td>47955.58</td>
      <td>8.34380</td>
      <td>4.001467e+05</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>349916</th>
      <td>2641770</td>
      <td>2022-08-31 23:56:00</td>
      <td>20148.68</td>
      <td>20155.55</td>
      <td>20143.12</td>
      <td>20151.50</td>
      <td>170.79243</td>
      <td>3.441419e+06</td>
    </tr>
    <tr>
      <th>349917</th>
      <td>2641771</td>
      <td>2022-08-31 23:57:00</td>
      <td>20152.62</td>
      <td>20153.10</td>
      <td>20130.85</td>
      <td>20142.19</td>
      <td>227.70751</td>
      <td>4.586203e+06</td>
    </tr>
    <tr>
      <th>349918</th>
      <td>2641772</td>
      <td>2022-08-31 23:58:00</td>
      <td>20143.65</td>
      <td>20151.31</td>
      <td>20136.47</td>
      <td>20145.66</td>
      <td>160.46265</td>
      <td>3.232340e+06</td>
    </tr>
    <tr>
      <th>349919</th>
      <td>2641773</td>
      <td>2022-08-31 23:59:00</td>
      <td>20144.40</td>
      <td>20158.24</td>
      <td>20138.16</td>
      <td>20140.63</td>
      <td>193.27150</td>
      <td>3.894068e+06</td>
    </tr>
    <tr>
      <th>349920</th>
      <td>2641774</td>
      <td>2022-09-01 00:00:00</td>
      <td>20142.26</td>
      <td>20166.17</td>
      <td>20131.97</td>
      <td>20158.42</td>
      <td>294.71744</td>
      <td>5.938896e+06</td>
    </tr>
  </tbody>
</table>
<p>349921 rows × 8 columns</p>

```python
# 对表进行过滤 只保留认可度较高的表 
tables = ['btc_usdt', 'eth_usdt', 'bch_usdt', 'xrp_usdt', 'eos_usdt', 'ltc_usdt', 'trx_usdt', 'etc_usdt',             'link_usdt', 'xlm_usdt', 'xmr_usdt', 'dash_usdt', 'zec_usdt', 'xtz_usdt', 'bnb_usdt', 'atom_usdt',
           'ont_usdt', 'iota_usdt', 'bat_usdt', 'vet_usdt', 'neo_usdt', 'qtum_usdt', 'iost_usdt','theta_usdt','algo_usdt', 'zil_usdt', 'knc_usdt', 'zrx_usdt', 'comp_usdt', 'omg_usdt', 'doge_usdt', 'sxp_usdt', 'kava_usdt',
          'band_usdt', 'rlc_usdt', 'waves_usdt', 'snx_usdt', 'dot_usdt', 'yfi_usdt', 'bal_usdt', 'crv_usdt', 'ada_usdt', 'trb_usdt', 'rune_usdt', 
          'sushi_usdt', 'srm_usdt', 'egld_usdt', 'sol_usdt', 'icx_usdt', 'blz_usdt', 'uni_usdt', 'avax_usdt', 'ftm_usdt', 'hnt_usdt', 'enj_usdt', 
          'flm_usdt', 'tomo_usdt', 'ksm_usdt', 'near_usdt', 'aave_usdt', 'fil_usdt', 'rsr_usdt', 'lrc_usdt', 'matic_usdt', 'ocean_usdt', 'cvc_usdt',
          'bel_usdt', 'ctk_usdt', 'axs_usdt', 'alpha_usdt', 'zen_usdt', 'skl_usdt', 'grt_usdt', '1inch_usdt', 'chz_usdt', 'sand_usdt', 'ankr_usdt', 
          'bts_usdt', 'unfi_usdt', 'reef_usdt', 'sfp_usdt', 'xem_usdt', 'coti_usdt', 'chr_usdt', 'mana_usdt', 'alice_usdt', 'hbar_usdt', 'one_usdt',
          'stmx_usdt', 'dent_usdt', 'celr_usdt', 'hot_usdt', 'mtl_usdt', 'ogn_usdt', 'nkn_usdt', 'sc_usdt', 'dgb_usdt', 'icp_usdt', 'tlm_usdt', 
          'iotx_usdt', 'audio_usdt', 'ray_usdt', 'c98_usdt', 'mask_usdt', 'ata_usdt', 'dydx_usdt', 'gala_usdt', 'celo_usdt', 'klay_usdt', 'arpa_usdt'
          , 'ctsi_usdt', 'ens_usdt', 'people_usdt', 'ant_usdt', 'rose_usdt', 'dusk_usdt', 'flow_usdt', 'imx_usdt', 'api3_usdt', 'gmt_usdt', 
          'ape_usdt', 'bnx_usdt', 'woo_usdt', 'ftt_usdt', 'jasmy_usdt', 'dar_usdt', 'gal_usdt', 'op_usdt', 'btc_usdt', 'eth_usdt', 'inj_usdt', 
          'stg_usdt', 'spell_usdt', 'ldo_usdt', 'cvx_usdt']
print(len(tables))
```

output: 135

```python
## 把所有数据存入文件 方便后续分析
for i in tables:
    df, error = export_table_by_date(i, date_columns, start_time, end_time)
    if df is None:
        print(f"Error exporting table {i}: {error}")
        continue

    if not df.empty:
        df = transfer_to_period_data(df, rule_type)
        df.index = pd.to_datetime(df["open_time_GMT8"])
        df_dict[i] = df
```

### 数据进行分组处理

```python
df_close = pd.DataFrame(index=pd.date_range(start=start_time, end=end_time, freq=rule_type),columns=df_dict.keys())
df_open = pd.DataFrame(index=pd.date_range(start=start_time, end=end_time, freq=rule_type),columns=df_dict.keys())
df_volume = pd.DataFrame(index=pd.date_range(start=start_time, end=end_time, freq=rule_type),columns=df_dict.keys())
df_amount = pd.DataFrame(index=pd.date_range(start=start_time, end=end_time, freq=rule_type),columns=df_dict.keys())

for symbol in df_dict.keys():
    df_s = df_dict[symbol]
    df_close[symbol] = df_s['close']
    df_open[symbol] = df_s['open']
    df_volume[symbol] = df_s['volume']
    df_amount[symbol] = df_s['amount']

    
   
df_close = df_close.dropna(how='all')
df_open = df_open.dropna(how='all')
df_volume = df_volume.dropna(how='all')
df_amount = df_count.dropna(how='all')
```

```python
# 归一化处理并输出
df_norm = df_close/df_close.fillna(method='bfill').iloc[0] #归一化
df_norm.mean(axis=1).plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/ldnZog3aycCT7NF.png)

我们可以看到行情非常差 从年初的1.0 到了9月份的0.3，市值跌倒开始的35%

### 回测引擎

```python
#回测引擎
class Exchange:
  
    def __init__(self, trade_symbols, fee=0.0004, initial_balance=10000):
        self.initial_balance = initial_balance #初始的资产
        self.fee = fee
        self.trade_symbols = trade_symbols
        self.account = {'USDT':{'realised_profit':0, 'unrealised_profit':0, 'total':initial_balance, 'fee':0, 'leverage':0, 'hold':0}}
        for symbol in trade_symbols:
            self.account[symbol] = {'amount':0, 'hold_price':0, 'value':0, 'price':0, 'realised_profit':0,'unrealised_profit':0,'fee':0}
          
    def Trade(self, symbol, direction, price, amount):
      
        cover_amount = 0 if direction*self.account[symbol]['amount'] >=0 else min(abs(self.account[symbol]['amount']), amount)
        open_amount = amount - cover_amount
        self.account['USDT']['realised_profit'] -= price*amount*self.fee #扣除手续费
        self.account['USDT']['fee'] += price*amount*self.fee
        self.account[symbol]['fee'] += price*amount*self.fee

        if cover_amount > 0: #先平仓
            self.account['USDT']['realised_profit'] += -direction*(price - self.account[symbol]['hold_price'])*cover_amount  #利润
            self.account[symbol]['realised_profit'] += -direction*(price - self.account[symbol]['hold_price'])*cover_amount
          
            self.account[symbol]['amount'] -= -direction*cover_amount
            self.account[symbol]['hold_price'] = 0 if self.account[symbol]['amount'] == 0 else self.account[symbol]['hold_price']
          
        if open_amount > 0:
            total_cost = self.account[symbol]['hold_price']*direction*self.account[symbol]['amount'] + price*open_amount
            total_amount = direction*self.account[symbol]['amount']+open_amount
          
            self.account[symbol]['hold_price'] = total_cost/total_amount
            self.account[symbol]['amount'] += direction*open_amount
                  
  
    def Buy(self, symbol, price, amount):
        self.Trade(symbol, 1, price, amount)
      
    def Sell(self, symbol, price, amount):
        self.Trade(symbol, -1, price, amount)
      
    def Update(self, close_price): #对资产进行更新
        self.account['USDT']['unrealised_profit'] = 0
        self.account['USDT']['hold'] = 0
        for symbol in self.trade_symbols:
            if not np.isnan(close_price[symbol]):
                self.account[symbol]['unrealised_profit'] = (close_price[symbol] - self.account[symbol]['hold_price'])*self.account[symbol]['amount']
                self.account[symbol]['price'] = close_price[symbol]
                self.account[symbol]['value'] = abs(self.account[symbol]['amount'])*close_price[symbol]
                self.account['USDT']['hold'] += self.account[symbol]['value']
                self.account['USDT']['unrealised_profit'] += self.account[symbol]['unrealised_profit']
        self.account['USDT']['total'] = round(self.account['USDT']['realised_profit'] + self.initial_balance + self.account['USDT']['unrealised_profit'],6)
        self.account['USDT']['leverage'] = round(self.account['USDT']['hold']/self.account['USDT']['total'],3)

#测试因子的函数
def Test(factor, symbols, period=1, N=40, value=300):
    e = Exchange(symbols, fee=0.0002, initial_balance=10000)
    res_list = []
    index_list = []
    factor = factor.dropna(how='all')
    for idx, row in factor.iterrows():
        if idx.hour % period == 0:
            buy_symbols =  row.sort_values().dropna()[0:N].index
            sell_symbols = row.sort_values().dropna()[-N:].index
            prices = df_close.loc[idx,]
            index_list.append(idx)
            for symbol in symbols:
                if symbol in buy_symbols and e.account[symbol]['amount'] <= 0:
                    e.Buy(symbol,prices[symbol],value/prices[symbol]-e.account[symbol]['amount'])
                if symbol in sell_symbols and e.account[symbol]['amount'] >= 0:
                    e.Sell(symbol,prices[symbol], value/prices[symbol]+e.account[symbol]['amount'])
            e.Update(prices)
            res_list.append([e.account['USDT']['total'],e.account['USDT']['hold']])
    return pd.DataFrame(data=res_list, columns=['total','hold'],index = index_list)
```

```python
#成交量
factor_volume = df_volume
factor_volume_res = Test(factor_volume, tables, period=4)
factor_volume_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/kXtQuevGBYHSl67.png)



```python
#3小时动量因子
factor_1 =  (df_close - df_close.shift(3))/df_close.shift(3)
factor_1_res = Test(factor_1,tables,period=1)
factor_1_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/EV8n1y7qUkpS3tH.png)

```python
#24小时动量因子
factor_1 =  (df_close - df_close.shift(24))/df_close.shift(3)
factor_1_res = Test(factor_1,tables,period=1)
factor_1_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/PX6tubcDIUMLECN.png)



```python
#成交量因子
factor_3 = df_volume.rolling(24).mean()/df_volume.rolling(96).mean()
factor_3_res = Test(factor_3, tables, period=8)
factor_3_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/QJIhoTDyAgbN2Gp.png)

```python
#波动率因子
factor_7 = (df_close/df_open).rolling(24).std()
factor_7_res = Test(factor_7, tables, period=2)
factor_7_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/Hosq4jl3hw1TRav.png)

```python
#成交量和收盘价相关性因子
factor_8 = df_close.rolling(96).corr(df_volume)
factor_8_res = Test(factor_8, tables, period=4)
factor_8_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/LMWGIzD52XdJsNV.png)

```python
#标准化函数，去除缺失值和极值，并且进行标准化处理
def norm_factor(factor):
    factor = factor.dropna(how='all')
    factor_clip = factor.apply(lambda x:x.clip(x.quantile(0.2), x.quantile(0.8)),axis=1)
    factor_norm = factor_clip.add(-factor_clip.mean(axis=1),axis ='index').div(factor_clip.std(axis=1),axis ='index')
    return factor_norm


df_volume_norm = norm_factor(df_volume)
factor_close_norm = norm_factor(factor_close)
factor_3_norm = norm_factor(factor_3)
factor_7_norm = norm_factor(factor_7)
factor_8_norm = norm_factor(factor_8)
```

### 多因子合成
```python
## 多因子回测
factor_total = 0.6*df_volume_norm + 0.4*factor_close_norm + 0.5*factor_3_norm + 0.3*factor_7_norm + 0.4*factor_8_norm
factor_total_res = Test(factor_total, tables, period=8)
factor_total_res.total.plot(figsize=(15,6),grid=True);
```

![](https://s2.loli.net/2023/09/02/GvJXMp7ZTkVAu3o.png)

## 总结

本文是发明者文章上的一个复现，仅仅修改了少量参数， 因此得到的结果也有类似之处。

在回测的数据中我们可以看出 多因子的表现还不如 动量的单因子表现，我们也正在寻找表现更好的多因子。多因子策略还有很多的玩法，很大的提升空间，希望我们可以一同探讨。
